Pval <- pt(T, win - 1) # Calculate p-value for each window
res<-cbind(win[which(Pval < p)],
dsum[which(Pval < p)],
dwin[which(Pval < p)],
Dsum[which(Pval < p)],
Dwin[which(Pval < p)]) # Combine results
Popt[row:(row + length(which(Pval < p)) - 1), ] <- res # Add results to running matrix of optimized simulations
row <- row + length(which(Pval < p)) - 1 # Increment row number for efficient data storage
}
summary(Popt)
View(d18Omat)
ncol(d18Omat)
colnames(d18Omat)[1201]
colnames(d18Omat)[1001]
d18Omat <- as.data.frame(matrix(rep(rnorm(length(d18Oc), d18Oc, SD_d18Oc), N), ncol = N)) # Randomly resample d18O data using measurement uncertainty
colnames(d18Omat) <- paste("Sim", seq(1, N, 1), sep = "")
D47mat <- as.data.frame(matrix(rep(rnorm(length(D47), D47, SD_D47), N), ncol = N)) # Randomly resample D47 data using measurement uncertainty
colnames(D47mat) <- paste("Sim", seq(1, N, 1), sep = "")
# Prepare data
Popt <- matrix(NA, ncol = 5, nrow = N * length(d18Oc)) # Create matrix with maximum length
colnames(Popt) <- c("optimal sample size",
"dOsum",
"dOwin",
"Dsum",
"Dwin") # Create template for storing simulation results
if(length(SD_d18Oc) == 1){
SD_d18Oc <- rep(SD_d18Oc, length(d18Oc)) # Duplicate SD of d18Oc error through entire record length if only a single value is given (constant uncertainty)
}
if(length(SD_D47) == 1){
SD_D47 <- rep(SD_D47, length(D47)) # Duplicate SD of D47 error through entire record length if only a single value is given (constant uncertainty)
}
d18Omat <- as.data.frame(matrix(rep(rnorm(length(d18Oc), d18Oc, SD_d18Oc), N), ncol = N)) # Randomly resample d18O data using measurement uncertainty
colnames(d18Omat) <- paste("Sim", seq(1, N, 1), sep = "")
D47mat <- as.data.frame(matrix(rep(rnorm(length(D47), D47, SD_D47), N), ncol = N)) # Randomly resample D47 data using measurement uncertainty
colnames(D47mat) <- paste("Sim", seq(1, N, 1), sep = "")
win <- seq(1, length(d18Oc), 1) # Create vector of sample size windows
row = 1
# MONTE CARLO SIMULATION
for(i in 1:N){ # Loop through all Monte Carlo simulations
# Progress
cat(paste("Sample size optimization Monte Carlo Iteration: ", i),"\r")
flush.console()
# Expanding window seasonality and T-test
# Keep record of summer and winter values for successful sample windows
# Isolate simulated d18O and D47 data
X <- cbind(d18Omat[, i], D47mat[, i])
# Sort by d18O (summer side of the record)
X <- X[order(X[, 1]), ]
dsum <- runMean(X[,  1] ,  1, cumulative = TRUE) # Calculate average summer d18O for progressively large sample size windows
Dsum <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average summer D47 for progressively large sample size windows
Dsumsd<-runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within summer D47 values for progressively large sample size windows
# Inverse sort by d18O (winter side of the record)
X <- X[order(X[, 1], decreasing = TRUE), ]
dwin <- runMean(X[, 1], 1, cumulative = TRUE) # Calculate average winter d18O for progressively large sample size windows
Dwin <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average winter D47 for progressively large sample size windows
Dwinsd <- runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within winter D47 values for progressively large sample size windows
# Calculate statistics of summer and winter separation for each sampling window
SDpool <- sqrt((Dsumsd ^ 2 + Dwinsd ^ 2) / 2) # Calculate pooled standard deviation for each window
T <- (Dsum - Dwin) / (SDpool * sqrt(2 / win)) # Calculate two-sample T-value for each window (equal sample size, equal variance)
Pval <- pt(T, win - 1) # Calculate p-value for each window
res<-cbind(win[which(Pval < p)],
dsum[which(Pval < p)],
dwin[which(Pval < p)],
Dsum[which(Pval < p)],
Dwin[which(Pval < p)]) # Combine results
Popt[row:(row + length(which(Pval < p)) - 1), ] <- res # Add results to running matrix of optimized simulations
row <- row + length(which(Pval < p)) - 1 # Increment row number for efficient data storage
}
summary(Popt)
length(which(all(is.na(Popt))))
length(complete.cases(Popt))
length(which(complete.cases(Popt)))
Popt <- as.data.frame(Popt[complete.cases(Popt), ])
View(Popt)
summary(Popt)
?runMean
# Prepare data
Popt <- matrix(NA, ncol = 5, nrow = N * length(d18Oc)) # Create matrix with maximum length
colnames(Popt) <- c("Samplesize",
"dOsum",
"dOwin",
"Dsum",
"Dwin") # Create template for storing simulation results
if(length(SD_d18Oc) == 1){
SD_d18Oc <- rep(SD_d18Oc, length(d18Oc)) # Duplicate SD of d18Oc error through entire record length if only a single value is given (constant uncertainty)
}
if(length(SD_D47) == 1){
SD_D47 <- rep(SD_D47, length(D47)) # Duplicate SD of D47 error through entire record length if only a single value is given (constant uncertainty)
}
d18Omat <- as.data.frame(matrix(rep(rnorm(length(d18Oc), d18Oc, SD_d18Oc), N), ncol = N)) # Randomly resample d18O data using measurement uncertainty
colnames(d18Omat) <- paste("Sim", seq(1, N, 1), sep = "")
D47mat <- as.data.frame(matrix(rep(rnorm(length(D47), D47, SD_D47), N), ncol = N)) # Randomly resample D47 data using measurement uncertainty
colnames(D47mat) <- paste("Sim", seq(1, N, 1), sep = "")
win <- seq(1, length(d18Oc), 1) # Create vector of sample size windows
row = 1
# MONTE CARLO SIMULATION
for(i in 1:N){ # Loop through all Monte Carlo simulations
# Progress
cat(paste("Sample size optimization Monte Carlo Iteration: ", i),"\r")
flush.console()
# Expanding window seasonality and T-test
# Keep record of summer and winter values for successful sample windows
# Isolate simulated d18O and D47 data
X <- cbind(d18Omat[, i], D47mat[, i])
# Sort by d18O (summer side of the record)
X <- X[order(X[, 1]), ]
dsum <- runMean(X[, 1] ,  1, cumulative = TRUE) # Calculate average summer d18O for progressively large sample size windows
Dsum <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average summer D47 for progressively large sample size windows
Dsumsd<-runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within summer D47 values for progressively large sample size windows
# Inverse sort by d18O (winter side of the record)
X <- X[order(X[, 1], decreasing = TRUE), ]
dwin <- runMean(X[, 1], 1, cumulative = TRUE) # Calculate average winter d18O for progressively large sample size windows
Dwin <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average winter D47 for progressively large sample size windows
Dwinsd <- runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within winter D47 values for progressively large sample size windows
# Calculate statistics of summer and winter separation for each sampling window
SDpool <- sqrt((Dsumsd ^ 2 + Dwinsd ^ 2) / 2) # Calculate pooled standard deviation for each window
T <- (Dsum - Dwin) / (SDpool * sqrt(2 / win)) # Calculate two-sample T-value for each window (equal sample size, equal variance)
Pval <- pt(T, win - 1) # Calculate p-value for each window
res<-cbind(win[which(Pval < p)],
dsum[which(Pval < p)],
dwin[which(Pval < p)],
Dsum[which(Pval < p)],
Dwin[which(Pval < p)]) # Combine results
Popt[row:(row + length(which(Pval < p)) - 1), ] <- res # Add results to running matrix of optimized simulations
row <- row + length(which(Pval < p)) - 1 # Increment row number for efficient data storage
}
# POST PROCESSING
Popt <- as.data.frame(Popt[complete.cases(Popt), ]) # Remove rows with NAs
Popt <- Popt[-which(Popt$Samplesize > (length(d18Oc) / 2)), ]
View(Case12)
ages <- Case12$Tnew
x11(); plot(ages)
D47_fun = "Bernasconi18"
d18O_fun = "KimONeil97"
# POST PROCESSING
Popt <- as.data.frame(Popt[complete.cases(Popt), ]) # Remove rows with NAs
Popt <- Popt[-which(Popt$Samplesize > (length(d18Oc) / 2)), ] # Remove simulations taking more than half of the samples (summer and winter samples overlap)
# Add temperature calculations of optimal runs
if(D47_fun == "Bernasconi18"){
Popt$Tsum <- sqrt((0.0449 * 10 ^ 6) / (as.numeric(Popt$Dsum - 0.167)) - 273.15)) # Calculate summer and winter temperatures for each successful simulation according to Kele et al., 2015 modified by Bernasconi et al., 2018
Popt$Twin <- sqrt((0.0449 * 10 ^ 6) / (as.numeric(Popt$Dwin - 0.167)) - 273.15))
}else if(D47_fun == "Jautzy20"){
Popt$Tsum <- sqrt((0.0433 * 10 ^ 6) / (as.numeric(Popt$Dsum - 0.119 + 0.066)) - 273.15)) # Calculate summer and inter temperatures for each successful simulation according to Jautzy et al., 2020 brought into 25 degrees CDES reference frame using 70-25 acid fractionation factor by Petersen et al., 2019
Popt$Twin <- sqrt((0.0433 * 10 ^ 6) / (as.numeric(Popt$Dwin - 0.119 + 0.066)) - 273.15))
}else{
return("ERROR: Supplied D47 transfer function is not recognized")
}
# Add seawater d18O calculations of optimal runs
if(d18O_fun == "KimONeil97"){
Popt$dOwsum <- ((as.numeric(Popt$dOsum) - (exp(((18.03 * 10 ^ 3) / (as.numeric(Popt$Tsum) + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92))) # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Kim and O'Neil, 1997 with conversion to PDB (following Brand et al., 2014)
Popt$dOwwin <- ((as.numeric(Popt$dOwin) - (exp(((18.03 * 10 ^ 3) / (as.numeric(Popt$Twin) + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92)))
}else if(d18O_fun == "GrossmanKu86"){
Popt$dOwsum <- (Popt$Tsum - 20.6) / 4.34 + Popt$dOsum - 0.2 # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Grossmann and Ku (1986) modified by Dettmann et al. (1999)
Popt$dOwwin <- (Popt$Twin - 20.6) / 4.34 + Popt$dOwin - 0.2
}else{
return("ERROR: Supplied d18Oc transfer function is not recognized")
}
# Add slopes and intercepts for D47-d18O conversion
Popt$D_dO_slope <- as.numeric(Popt$Dsum) - as.numeric(Popt$Dwin)) / (as.numeric(Popt$dOsum) - as.numeric(Popt$dOwin))))
Popt$D_dO_int <- ((as.numeric(Popt$Dsum) + as.numeric(Popt$Dwin)) / 2) - as.numeric(Popt$D_dO_slope) * ((as.numeric(Popt$dOsum) + as.numeric(Popt$dOwin)) / 2)))
# OPTIONAL: Export results of optimized sample sizes
if(export_raw == TRUE){
write.csv(Popt, "Optimum_simulations.csv")
}
# Prepare data
Popt <- matrix(NA, ncol = 5, nrow = N * length(d18Oc)) # Create matrix with maximum length
colnames(Popt) <- c("Samplesize",
"dOsum",
"dOwin",
"Dsum",
"Dwin") # Create template for storing simulation results
if(length(SD_d18Oc) == 1){
SD_d18Oc <- rep(SD_d18Oc, length(d18Oc)) # Duplicate SD of d18Oc error through entire record length if only a single value is given (constant uncertainty)
}
if(length(SD_D47) == 1){
SD_D47 <- rep(SD_D47, length(D47)) # Duplicate SD of D47 error through entire record length if only a single value is given (constant uncertainty)
}
d18Omat <- as.data.frame(matrix(rep(rnorm(length(d18Oc), d18Oc, SD_d18Oc), N), ncol = N)) # Randomly resample d18O data using measurement uncertainty
colnames(d18Omat) <- paste("Sim", seq(1, N, 1), sep = "")
D47mat <- as.data.frame(matrix(rep(rnorm(length(D47), D47, SD_D47), N), ncol = N)) # Randomly resample D47 data using measurement uncertainty
colnames(D47mat) <- paste("Sim", seq(1, N, 1), sep = "")
win <- seq(1, length(d18Oc), 1) # Create vector of sample size windows
row = 1
# MONTE CARLO SIMULATION
for(i in 1:N){ # Loop through all Monte Carlo simulations
# Progress
cat(paste("Sample size optimization Monte Carlo Iteration: ", i),"\r")
flush.console()
# Expanding window seasonality and T-test
# Keep record of summer and winter values for successful sample windows
# Isolate simulated d18O and D47 data
X <- cbind(d18Omat[, i], D47mat[, i])
# Sort by d18O (summer side of the record)
X <- X[order(X[, 1]), ]
dsum <- runMean(X[, 1] ,  1, cumulative = TRUE) # Calculate average summer d18O for progressively large sample size windows
Dsum <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average summer D47 for progressively large sample size windows
Dsumsd<-runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within summer D47 values for progressively large sample size windows
# Inverse sort by d18O (winter side of the record)
X <- X[order(X[, 1], decreasing = TRUE), ]
dwin <- runMean(X[, 1], 1, cumulative = TRUE) # Calculate average winter d18O for progressively large sample size windows
Dwin <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average winter D47 for progressively large sample size windows
Dwinsd <- runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within winter D47 values for progressively large sample size windows
# Calculate statistics of summer and winter separation for each sampling window
SDpool <- sqrt((Dsumsd ^ 2 + Dwinsd ^ 2) / 2) # Calculate pooled standard deviation for each window
T <- (Dsum - Dwin) / (SDpool * sqrt(2 / win)) # Calculate two-sample T-value for each window (equal sample size, equal variance)
Pval <- pt(T, win - 1) # Calculate p-value for each window
res<-cbind(win[which(Pval < p)],
dsum[which(Pval < p)],
dwin[which(Pval < p)],
Dsum[which(Pval < p)],
Dwin[which(Pval < p)]) # Combine results
Popt[row:(row + length(which(Pval < p)) - 1), ] <- res # Add results to running matrix of optimized simulations
row <- row + length(which(Pval < p)) - 1 # Increment row number for efficient data storage
}
# POST PROCESSING
Popt <- as.data.frame(Popt[complete.cases(Popt), ]) # Remove rows with NAs
Popt <- Popt[-which(Popt$Samplesize > (length(d18Oc) / 2)), ] # Remove simulations taking more than half of the samples (summer and winter samples overlap)
# Add temperature calculations of optimal runs
if(D47_fun == "Bernasconi18"){
Popt$Tsum <- sqrt((0.0449 * 10 ^ 6) / (as.numeric(Popt$Dsum - 0.167)) - 273.15)) # Calculate summer and winter temperatures for each successful simulation according to Kele et al., 2015 modified by Bernasconi et al., 2018
Popt$Twin <- sqrt((0.0449 * 10 ^ 6) / (as.numeric(Popt$Dwin - 0.167)) - 273.15))
}else if(D47_fun == "Jautzy20"){
Popt$Tsum <- sqrt((0.0433 * 10 ^ 6) / (as.numeric(Popt$Dsum - 0.119 + 0.066)) - 273.15)) # Calculate summer and inter temperatures for each successful simulation according to Jautzy et al., 2020 brought into 25 degrees CDES reference frame using 70-25 acid fractionation factor by Petersen et al., 2019
Popt$Twin <- sqrt((0.0433 * 10 ^ 6) / (as.numeric(Popt$Dwin - 0.119 + 0.066)) - 273.15))
}else{
return("ERROR: Supplied D47 transfer function is not recognized")
}
# Add seawater d18O calculations of optimal runs
if(d18O_fun == "KimONeil97"){
Popt$dOwsum <- (as.numeric(Popt$dOsum) - (exp(((18.03 * 10 ^ 3) / (as.numeric(Popt$Tsum) + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92 # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Kim and O'Neil, 1997 with conversion to PDB (following Brand et al., 2014)
Popt$dOwwin <- (as.numeric(Popt$dOwin) - (exp(((18.03 * 10 ^ 3) / (as.numeric(Popt$Twin) + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92
}else if(d18O_fun == "GrossmanKu86"){
Popt$dOwsum <- (Popt$Tsum - 20.6) / 4.34 + Popt$dOsum - 0.2 # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Grossmann and Ku (1986) modified by Dettmann et al. (1999)
Popt$dOwwin <- (Popt$Twin - 20.6) / 4.34 + Popt$dOwin - 0.2
}else{
return("ERROR: Supplied d18Oc transfer function is not recognized")
}
# Add temperature calculations of optimal runs
if(D47_fun == "Bernasconi18"){
Popt$Tsum <- sqrt((0.0449 * 10 ^ 6) / (as.numeric(Popt$Dsum - 0.167)) - 273.15) # Calculate summer and winter temperatures for each successful simulation according to Kele et al., 2015 modified by Bernasconi et al., 2018
Popt$Twin <- sqrt((0.0449 * 10 ^ 6) / (as.numeric(Popt$Dwin - 0.167)) - 273.15)
}else if(D47_fun == "Jautzy20"){
Popt$Tsum <- sqrt((0.0433 * 10 ^ 6) / (as.numeric(Popt$Dsum - 0.119 + 0.066)) - 273.15) # Calculate summer and inter temperatures for each successful simulation according to Jautzy et al., 2020 brought into 25 degrees CDES reference frame using 70-25 acid fractionation factor by Petersen et al., 2019
Popt$Twin <- sqrt((0.0433 * 10 ^ 6) / (as.numeric(Popt$Dwin - 0.119 + 0.066)) - 273.15)
}else{
return("ERROR: Supplied D47 transfer function is not recognized")
}
# Add seawater d18O calculations of optimal runs
if(d18O_fun == "KimONeil97"){
Popt$dOwsum <- (as.numeric(Popt$dOsum) - (exp(((18.03 * 10 ^ 3) / (as.numeric(Popt$Tsum) + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92 # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Kim and O'Neil, 1997 with conversion to PDB (following Brand et al., 2014)
Popt$dOwwin <- (as.numeric(Popt$dOwin) - (exp(((18.03 * 10 ^ 3) / (as.numeric(Popt$Twin) + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92
}else if(d18O_fun == "GrossmanKu86"){
Popt$dOwsum <- (Popt$Tsum - 20.6) / 4.34 + Popt$dOsum - 0.2 # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Grossmann and Ku (1986) modified by Dettmann et al. (1999)
Popt$dOwwin <- (Popt$Twin - 20.6) / 4.34 + Popt$dOwin - 0.2
}else{
return("ERROR: Supplied d18Oc transfer function is not recognized")
}
Popt$D_dO_slope <- (as.numeric(Popt$Dsum) - as.numeric(Popt$Dwin)) / (as.numeric(Popt$dOsum) - as.numeric(Popt$dOwin))
Popt$D_dO_int <- ((as.numeric(Popt$Dsum) + as.numeric(Popt$Dwin)) / 2) - as.numeric(Popt$D_dO_slope) * ((as.numeric(Popt$dOsum) + as.numeric(Popt$dOwin)) / 2)
?round
month = ceiling((ages %% 1) * 12)
resultmat <- data.frame(d18Oc = d18Oc, # Group d18Oc and age data
month = ceiling((ages %% 1) * 12) # Use age data to group results into monthly bins
)
View(resultmat)
summary(Popt)
str(Popt)
# Prepare data
Popt <- matrix(NA, ncol = 5, nrow = N * length(d18Oc)) # Create matrix with maximum length
colnames(Popt) <- c("Samplesize",
"dOsum",
"dOwin",
"Dsum",
"Dwin") # Create template for storing simulation results
if(length(SD_d18Oc) == 1){
SD_d18Oc <- rep(SD_d18Oc, length(d18Oc)) # Duplicate SD of d18Oc error through entire record length if only a single value is given (constant uncertainty)
}
if(length(SD_D47) == 1){
SD_D47 <- rep(SD_D47, length(D47)) # Duplicate SD of D47 error through entire record length if only a single value is given (constant uncertainty)
}
d18Omat <- as.data.frame(matrix(rep(rnorm(length(d18Oc), d18Oc, SD_d18Oc), N), ncol = N)) # Randomly resample d18O data using measurement uncertainty
colnames(d18Omat) <- paste("Sim", seq(1, N, 1), sep = "")
D47mat <- as.data.frame(matrix(rep(rnorm(length(D47), D47, SD_D47), N), ncol = N)) # Randomly resample D47 data using measurement uncertainty
colnames(D47mat) <- paste("Sim", seq(1, N, 1), sep = "")
win <- seq(1, length(d18Oc), 1) # Create vector of sample size windows
row = 1
# MONTE CARLO SIMULATION
for(i in 1:N){ # Loop through all Monte Carlo simulations
# Progress
cat(paste("Sample size optimization Monte Carlo Iteration: ", i),"\r")
flush.console()
# Expanding window seasonality and T-test
# Keep record of summer and winter values for successful sample windows
# Isolate simulated d18O and D47 data
X <- cbind(d18Omat[, i], D47mat[, i])
# Sort by d18O (summer side of the record)
X <- X[order(X[, 1]), ]
dsum <- runMean(X[, 1] ,  1, cumulative = TRUE) # Calculate average summer d18O for progressively large sample size windows
Dsum <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average summer D47 for progressively large sample size windows
Dsumsd<-runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within summer D47 values for progressively large sample size windows
# Inverse sort by d18O (winter side of the record)
X <- X[order(X[, 1], decreasing = TRUE), ]
dwin <- runMean(X[, 1], 1, cumulative = TRUE) # Calculate average winter d18O for progressively large sample size windows
Dwin <- runMean(X[, 2], 1, cumulative = TRUE) # Calculate average winter D47 for progressively large sample size windows
Dwinsd <- runSD(X[, 2], 1, cumulative = TRUE) # Calculate standard deviation within winter D47 values for progressively large sample size windows
# Calculate statistics of summer and winter separation for each sampling window
SDpool <- sqrt((Dsumsd ^ 2 + Dwinsd ^ 2) / 2) # Calculate pooled standard deviation for each window
T <- (Dsum - Dwin) / (SDpool * sqrt(2 / win)) # Calculate two-sample T-value for each window (equal sample size, equal variance)
Pval <- pt(T, win - 1) # Calculate p-value for each window
res<-cbind(win[which(Pval < p)],
dsum[which(Pval < p)],
dwin[which(Pval < p)],
Dsum[which(Pval < p)],
Dwin[which(Pval < p)]) # Combine results
Popt[row:(row + length(which(Pval < p)) - 1), ] <- res # Add results to running matrix of optimized simulations
row <- row + length(which(Pval < p)) - 1 # Increment row number for efficient data storage
}
# POST PROCESSING
Popt <- as.data.frame(Popt[complete.cases(Popt), ]) # Remove rows with NAs
Popt <- Popt[-which(Popt$Samplesize > (length(d18Oc) / 2)), ] # Remove simulations taking more than half of the samples (summer and winter samples overlap)
# Add temperature calculations of optimal runs
if(D47_fun == "Bernasconi18"){
Popt$Tsum <- sqrt((0.0449 * 10 ^ 6) / (Popt$Dsum - 0.167)) - 273.15 # Calculate summer and winter temperatures for each successful simulation according to Kele et al., 2015 modified by Bernasconi et al., 2018
Popt$Twin <- sqrt((0.0449 * 10 ^ 6) / (Popt$Dwin - 0.167)) - 273.15
}else if(D47_fun == "Jautzy20"){
Popt$Tsum <- sqrt((0.0433 * 10 ^ 6) / (Popt$Dsum - 0.119 + 0.066)) - 273.15 # Calculate summer and inter temperatures for each successful simulation according to Jautzy et al., 2020 brought into 25 degrees CDES reference frame using 70-25 acid fractionation factor by Petersen et al., 2019
Popt$Twin <- sqrt((0.0433 * 10 ^ 6) / (Popt$Dwin - 0.119 + 0.066)) - 273.15
}else{
return("ERROR: Supplied D47 transfer function is not recognized")
}
# Add seawater d18O calculations of optimal runs
if(d18O_fun == "KimONeil97"){
Popt$dOwsum <- (Popt$dOsum - (exp(((18.03 * 10 ^ 3) / (Popt$Tsum + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92 # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Kim and O'Neil, 1997 with conversion to PDB (following Brand et al., 2014)
Popt$dOwwin <- (Popt$dOwin - (exp(((18.03 * 10 ^ 3) / (Popt$Twin + 273.15) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92
}else if(d18O_fun == "GrossmanKu86"){
Popt$dOwsum <- (Popt$Tsum - 20.6) / 4.34 + Popt$dOsum - 0.2 # Calculate d18O of the precipitation fluid (dOw) for summer and winter simulations using Grossmann and Ku (1986) modified by Dettmann et al. (1999)
Popt$dOwwin <- (Popt$Twin - 20.6) / 4.34 + Popt$dOwin - 0.2
}else{
return("ERROR: Supplied d18Oc transfer function is not recognized")
}
# Add slopes and intercepts for D47-d18O conversion
Popt$D_dO_slope <- (Popt$Dsum - Popt$Dwin) / (Popt$dOsum - Popt$dOwin)
Popt$D_dO_int <- ((Popt$Dsum + Popt$Dwin) / 2) - Popt$D_dO_slope * ((Popt$dOsum + Popt$dOwin) / 2)
str(Popt)
resultmat <- data.frame(d18Oc = d18Oc, # Group d18Oc and age data
month = ceiling((ages %% 1) * 12) # Use age data to group results into monthly bins
)
View(resultmat)
View(Popt)
colnames(Popt)[10]
?rep
D47res <- outer(resultmat$d18Oc, Popt$D_dO_slope) + rep(Popt$D_dO_int, length(resultmat$d18Oc))
D47res <- outer(resultmat$d18Oc, Popt$D_dO_slope) + Popt$D_dO_int
D47res <- cbind(resultmat$month, outer(resultmat$d18Oc, Popt$D_dO_slope) + Popt$D_dO_int)
D47res <- outer(resultmat$d18Oc, Popt$D_dO_slope) + Popt$D_dO_int
gc()
D47res <- outer(resultmat$d18Oc, Popt$D_dO_slope) + Popt$D_dO_int
?group_by
require(ggpubr)
require(dplyr)
D47_monthly <- cbind(resultmat$month, outer(resultmat$d18Oc, Popt$D_dO_slope) + Popt$D_dO_int) %>% # Summarize modelled d18O statistics
ggpubr::group_by(month) %>%
dplyr::summarize(
mean = mean()
)
rm(D47res)
D47_monthly <- cbind(resultmat$month, outer(resultmat$d18Oc, Popt$D_dO_slope) + Popt$D_dO_int) %>% # Summarize modelled d18O statistics
ggpubr::group_by(month) %>%
dplyr::summarize(
mean = mean()
)
D47_monthly <- data.frame(means = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1))
View(D47_monthly)
D47_monthly <- data.frame(D47_mean = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
D47_median = vapply(1:12, function(x) median(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
SD_D47 = vapply(1:12, function(x) sd(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
)
D47_monthly <- data.frame(D47_mean = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
D47_median = vapply(1:12, function(x) median(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
SD_D47 = vapply(1:12, function(x) sd(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1)
)
D47_monthly <- data.frame(D47_mean = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
D47_median = vapply(1:12, function(x) median(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
SD_D47 = vapply(1:12, function(x) sd(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
SE_D47 = SD_D47 / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
)
View(D47_monthly)
D47_monthly <- data.frame(D47_mean = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1))
D47_monthly <- data.frame(D47_mean = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
D47_median = vapply(1:12, function(x) median(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
SD_D47 = vapply(1:12, function(x) sd(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1))
D47_monthly <- data.frame(D47_mean = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
D47_median = vapply(1:12, function(x) median(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
SD_D47 = vapply(1:12, function(x) sd(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
SE_D47 = D47_monthly$SD_D47 / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
)
colnames(D47_monthly)[c(3,4)]
colnames(D47_monthly)[c(3,4)] <- c("D47_SD", "D47_SE")
if(D47_fun == "Bernasconi18"){
T_monthly <- data.frame(T_mean = vapply(1:12, function(x) mean((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167) - 273.15), 1),
T_median = vapply(1:12, function(x) median((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167) - 273.15), 1),
T_SD = vapply(1:12, function(x) sd((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167) - 273.15), 1),
T_SE = T_monthly$T_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
)
}else if(D47_fun == "Jautzy20"){
T_monthly <- data.frame(T_mean = vapply(1:12, function(x) mean((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066) - 273.15), 1),
T_median = vapply(1:12, function(x) median((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066) - 273.15), 1),
T_SD = vapply(1:12, function(x) sd((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066) - 273.15), 1),
T_SE = T_monthly$T_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
)
}
rm(D47_monthly)
cat("Grouping D47 data into monthly bins: ", "\r")
D47_monthly <- data.frame(D47_mean = vapply(1:12, function(x) mean(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
D47_median = vapply(1:12, function(x) median(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1),
D47_SD = vapply(1:12, function(x) sd(outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int), 1)
)
D47_monthly$D47_SE = D47_monthly$SD_D47 / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
View(D47_monthly)
D47_monthly$D47_SE = D47_monthly$D47_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
cat("Grouping Temperature data into monthly bins: ", "\r")
if(D47_fun == "Bernasconi18"){
T_monthly <- data.frame(T_mean = vapply(1:12, function(x) mean((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167) - 273.15), 1),
T_median = vapply(1:12, function(x) median((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167) - 273.15), 1),
T_SD = vapply(1:12, function(x) sd((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167) - 273.15), 1)
)
}else if(D47_fun == "Jautzy20"){
T_monthly <- data.frame(T_mean = vapply(1:12, function(x) mean((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066) - 273.15), 1),
T_median = vapply(1:12, function(x) median((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066) - 273.15), 1),
T_SD = vapply(1:12, function(x) sd((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066) - 273.15), 1)
)
}
View(T_monthly)
cat("Grouping Temperature data into monthly bins: ", "\r")
if(D47_fun == "Bernasconi18"){
T_monthly <- data.frame(T_mean = vapply(1:12, function(x) mean(sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 273.15), 1),
T_median = vapply(1:12, function(x) median(sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 273.15), 1),
T_SD = vapply(1:12, function(x) sd(sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 273.15), 1)
)
}else if(D47_fun == "Jautzy20"){
T_monthly <- data.frame(T_mean = vapply(1:12, function(x) mean(sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 273.15), 1),
T_median = vapply(1:12, function(x) median(sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 273.15), 1),
T_SD = vapply(1:12, function(x) sd(sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 273.15), 1)
)
}
View(T_monthly)
T_monthly$T_SE = T_monthly$T_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
d18Ow_monthly <- data.frame(d18Ow_mean = vapply(1:12, function(x) mean((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1))
View(d18Ow_monthly)
d18Ow_monthly <- data.frame(d18Ow_mean = vapply(1:12, function(x) mean((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1),
d18Ow_median = vapply(1:12, function(x) median((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1),
d18Ow_SD = vapply(1:12, function(x) sd((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1)
)
rm(d18Ow_monthly)
if(d18O_fun == "KimONeil97"){
if(D47_fun == "Bernasconi18"){
d18Ow_monthly <- data.frame(d18Ow_mean = vapply(1:12, function(x) mean((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1),
d18Ow_median = vapply(1:12, function(x) median((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1),
d18Ow_SD = vapply(1:12, function(x) sd((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1)
)
}else if(D47_fun == "Jautzy20"){
d18Ow_monthly <- data.frame(d18Ow_mean = vapply(1:12, function(x) mean((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1),
d18Ow_median = vapply(1:12, function(x) median((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1),
d18Ow_SD = vapply(1:12, function(x) sd((resultmat$d18Oc[which(resultmat$month == x)] - (exp(((18.03 * 10 ^ 3) / sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 32.42) / 1000) - 1) * 1000) * 1.03092 + 30.92), 1)
)
}
}else if(d18O_fun == "GrossmanKu86"){
if(D47_fun == "Bernasconi18"){
d18Ow_monthly <- data.frame(d18Ow_mean = vapply(1:12, function(x) mean(resultmat$d18Oc[which(resultmat$month == x)] + ((sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 273.15) - 20.6) / 4.34 - 0.2), 1),
d18Ow_median = vapply(1:12, function(x) median(resultmat$d18Oc[which(resultmat$month == x)] + ((sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 273.15) - 20.6) / 4.34 - 0.2), 1),
d18Ow_SD = vapply(1:12, function(x) sd(resultmat$d18Oc[which(resultmat$month == x)] + ((sqrt((0.0449 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.167)) - 273.15) - 20.6) / 4.34 - 0.2), 1)
)
}else if(D47_fun == "Jautzy20"){
d18Ow_monthly <- data.frame(d18Ow_mean = vapply(1:12, function(x) mean(resultmat$d18Oc[which(resultmat$month == x)] + ((sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 273.15) - 20.6) / 4.34 - 0.2), 1),
d18Ow_median = vapply(1:12, function(x) median(resultmat$d18Oc[which(resultmat$month == x)] + ((sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 273.15) - 20.6) / 4.34 - 0.2), 1),
d18Ow_SD = vapply(1:12, function(x) sd(resultmat$d18Oc[which(resultmat$month == x)] + ((sqrt((0.0433 * 10 ^ 6) / (outer(resultmat$d18Oc[which(resultmat$month == x)], Popt$D_dO_slope) + Popt$D_dO_int - 0.119 + 0.066)) - 273.15) - 20.6) / 4.34 - 0.2), 1)
)
}
}
View(d18Ow_monthly)
d18Ow_monthly$d18Ow_SE = d18Ow_monthly$d18Ow_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
d18Oc_monthly <- data.frame(d18Oc_mean = vapply(1:12, function(x) mean(resultmat$d18Oc[which(resultmat$month == x)]), 1),
d18Oc_median = vapply(1:12, function(x) median(resultmat$d18Oc[which(resultmat$month == x)]), 1),
d18Oc_SD = vapply(1:12, function(x) sd(resultmat$d18Oc[which(resultmat$month == x)]), 1)
)
d18Ow_monthly$d18Ow_SE <- d18Ow_monthly$d18Ow_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
View(d18Oc_monthly)
d18Ow_monthly$d18Ow_SE = d18Ow_monthly$d18Ow_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
d18Oc_monthly$d18Oc_SE <- d18Ow_monthly$d18Oc_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
d18Oc_monthly$d18Oc_SE <- d18Oc_monthly$d18Oc_SD / sqrt(vapply(1:12, function(x) length(resultmat$d18Oc[which(resultmat$month == x)]), 1))
monthly<-cbind(d18Oc_monthly,
D47_monthly,
T_monthly,
d18Ow_monthly)
View(monthly)
length(d18Oc) == length(D47) == length(ages)
?equal
unique(c(length(d18Oc), length(D47), length(ages))
)
ages = ages[-1]
unique(c(length(d18Oc), length(D47), length(ages)))
str(monthly)
?use_data
devtools::use_data
require(usethis)
require(use_this)
?use_data
Case1 <- seasonalclumped:::Case1
Case1 <- seasonalclumped:::Case1.rda
load("E:/Dropbox/Research/postdoc/UNBIAS/seasonalclumped/data/Case1.rda")
View(Case1)
colnames(Case1)
