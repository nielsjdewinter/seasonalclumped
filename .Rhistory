?fft
require(astrochron)
?lm
install.packages(c("cli", "data.table", "ggpmisc", "gh", "globals", "isoband", "lme4", "patchwork", "processx", "ps", "radiant.data", "RcppArmadillo", "rlang", "shinyFiles", "xlsx"))
devtools::document()
carbmodel<-function(time,
SST,
GR,
d18Ow,
D,
d18O_fun = "KimONeil97",
D47_fun = "Bernasconi18",
AV=FALSE,
plot=FALSE
){
Dday<-cumsum(GR) # Create vector linking days to depth values
if(AV==FALSE){
SSTnew <- subsample(SST, Dday, D) # Subsample SST along the new sample set
d18Ownew <- subsample(d18Ow, Dday, D) # Subsample d18Ow along the new sample set
Tnew <- subsample(Ty, Dday, D) # Subsample time (yr) along the new sample set
}else{
SSTnew <- subsample_mean(SST, Dday, D) # Subsample SST along the new sample set using mean values
d18Ownew <- subsample_mean(d18Ow, Dday, D) # Subsample d18Ow along the new sample set using mean values
Tnew <- subsample_mean(Ty, Dday, D) # Subsample time (yr) along the new sample set using mean values
}
if(d18O_fun == "KimONeil97"){
alpha = exp((18.03 * 1000 / (SSTnew + 273.15) - 33.42) / 1000) # Calculate alpha of calcite fractionation
d18Ow_PDB = (0.97002 * d18Ownew - 29.98) # Convert d18Ow to PDB (following Brand et al., 2014)
d18Oc = ((alpha * (d18Ow_PDB / 1000 + 1)) - 1) * 1000 # Calculate d18O of calcite for each sample according to Kim and O'Neil, 1997
}else if(d18O_fun == "GrossmanKu86"){
d18Oc <- (20.6 - SSTnew) / 4.34 + d18Ow + 0.2 # Use Grossmann and Ku (1986) modified by Dettmann et al. (1999)
}else{
return("ERROR: Supplied d18Oc transfer function is not recognized")
}
if(D47_fun == "Bernasconi18"){
D47 <- (0.0449 * 10 ^ 6) / (SSTnew + 273.15) ^ 2 + 0.167 # Calculate D47 of calcite for each sample according to Kele et al., 2015 modified by Bernasconi et al., 2018
}else if(D47_fun == "Jautzy20"){
D47 <- (0.0433 * 10 ^ 6) / (SSTnew + 273.15) ^ 2 + 0.119 + 0.066 # Calculate D47 of calcite for each sample according to Jautzy et al., 2020 brought into 25 degrees CDES reference frame using 70-25 acid fractionation factor by Petersen et al., 2019
}else{
return("ERROR: Supplied D47 transfer function is not recognized")
}
if(plot == TRUE){ # Create plots of new data if requested
plot(D, d18Oc, col = "blue")
par(new = TRUE)
plot(D, D47, axes = FALSE, bty = "n", xlab = "", ylab = "", col = "red")
axis(side = 4, at = pretty(range(D47)))
}
dat<-cbind(Tnew, D, d18Oc, D47) # Combine new data for export
return(dat) # Return the new depth, d18Oc and D47 series
}
# Create test data (= ideal case)
# Set boundary conditions
Td <- seq(1, 12 * 365, 1) # Create timeline of 12 years in days
Ty <- Td / 365 # Convert to years
MAT <- 20 # Set mean annual temperature
Amp <- 10 # Set seasonal amplitude
Sext <- 2 * Amp # Calculate extent of seasonal variability
TSD <- 1.5 # Set the degree of random non-seasonal noise on the SST curve
("weather")
SST <- rnorm(length(Ty), MAT + Amp * sin(2 * pi * Ty), TSD) # Create virtual
daily SST data
GR <- rep(10 / 365, length(Ty)) # Set growth rate to 10 mm/yr and create daily
GR vector
DSD <- 0.6 # Set the degree of random non-seasonal noise on the d18Osw curve
("salinity fluctuations")
d18Osw<-rnorm(length(Ty), rep(0, length(Ty)), DSD) # Set d18Osw to 0 permille
VSMOW, create daily d18Osw vector
SR <- 0.75 # Set sampling resolution to 0.75 mm
# Create test data (= ideal case)
# Set boundary conditions
Td <- seq(1, 12 * 365, 1) # Create timeline of 12 years in days
Ty <- Td / 365 # Convert to years
MAT <- 20 # Set mean annual temperature
Amp <- 10 # Set seasonal amplitude
Sext <- 2 * Amp # Calculate extent of seasonal variability
TSD <- 1.5 # Set the degree of random non-seasonal noise on the SST curve
# ("weather")
SST <- rnorm(length(Ty), MAT + Amp * sin(2 * pi * Ty), TSD) # Create virtual
# daily SST data
GR <- rep(10 / 365, length(Ty)) # Set growth rate to 10 mm/yr and create daily
# GR vector
DSD <- 0.6 # Set the degree of random non-seasonal noise on the d18Osw curve
# ("salinity fluctuations")
d18Osw<-rnorm(length(Ty), rep(0, length(Ty)), DSD) # Set d18Osw to 0 permille
# VSMOW, create daily d18Osw vector
SR <- 0.75 # Set sampling resolution to 0.75 mm
D <- seq(SR, sum(GR), SR)
newdata <- carbmodel(Ty, SST, GR, d18Osw, D, AV = TRUE)
subsample<-function(dailydata,dailydepth,newdepth,plot=FALSE){
newdata<-vector()
for(i in 1:length(newdepth)){ # Loop through all new depth values (samples)
pos<-length(which(newdepth[i]>dailydepth)) # Find the position of the highest depth value below the sample
newdata<-append(newdata,dailydata[pos]+(newdepth[i]-dailydepth[pos])*(dailydata[pos+1]-dailydata[pos])/(dailydepth[pos+1]-dailydepth[pos])) # Calculate the new data value for each sample by linear interpolation
}
if(plot==TRUE){ # Create plot showing subsampling if requested
dev.new()
plot(dailydepth,dailydata,type="l")
points(newdepth,newdata,col="red")
}
return(newdata)
}
# Function used to linearly subsample data at new depth values
subsample_mean<-function(dailydata,dailydepth,newdepth,plot=FALSE){
newdata<-vector()
for(i in 1:length(newdepth)){ # Loop through all new depth values (samples)
# Find start and end positions of range to average
if(i==1){
pos1<-1 # If first sample of the record, then start position is equal to start of the record (pos1 = 1)
pos2<-length(which((newdepth[i+1]+newdepth[i])/2>dailydepth)) # End position is equal to the middle between the sample depth and the depth of the next sample
} else{
if(i==length(newdepth)){
pos1<-length(which((newdepth[i-1]+newdepth[i])/2>dailydepth)) # Start position is equal to the middle between the sample depth and the depth of the previous sample
pos2<-length(dailydepth) # If last sample of the record, then the last position is equal to the end of the record (pos2 = length(dailydepth))
} else{
pos1<-length(which((newdepth[i-1]+newdepth[i])/2>dailydepth)) # Start position is equal to the middle between the sample depth and the depth of the previous sample
pos2<-length(which((newdepth[i+1]+newdepth[i])/2>dailydepth)) # End position is equal to the middle between the sample depth and the depth of the next sample
}
}
newdata<-append(newdata,mean(dailydata[pos1:pos2]))# Calculate the new data value for each sample by averaging the range of datapoints between start and end position
}
if(plot==TRUE){ # Create plot showing subsampling if requested
dev.new()
plot(dailydepth,dailydata,type="l")
points(newdepth,newdata,col="red")
}
return(newdata)
}
newdata <- carbmodel(Ty, SST, GR, d18Osw, D, AV = TRUE)
View(newdata)
x11()
newdata <- carbmodel(Ty, SST, GR, d18Osw, D, AV = TRUE, plot = TRUE)
carbmodel<-function(time,
SST,
GR,
d18Ow,
D,
d18O_fun = "KimONeil97",
D47_fun = "Bernasconi18",
AV=FALSE,
plot=FALSE
){
Dday<-cumsum(GR) # Create vector linking days to depth values
if(AV==FALSE){
SSTnew <- subsample(SST, Dday, D) # Subsample SST along the new sample set
d18Ownew <- subsample(d18Ow, Dday, D) # Subsample d18Ow along the new sample set
Tnew <- subsample(Ty, Dday, D) # Subsample time (yr) along the new sample set
}else{
SSTnew <- subsample_mean(SST, Dday, D) # Subsample SST along the new sample set using mean values
d18Ownew <- subsample_mean(d18Ow, Dday, D) # Subsample d18Ow along the new sample set using mean values
Tnew <- subsample_mean(Ty, Dday, D) # Subsample time (yr) along the new sample set using mean values
}
if(d18O_fun == "KimONeil97"){
alpha = exp((18.03 * 1000 / (SSTnew + 273.15) - 33.42) / 1000) # Calculate alpha of calcite fractionation
d18Ow_PDB = (0.97002 * d18Ownew - 29.98) # Convert d18Ow to PDB (following Brand et al., 2014)
d18Oc = ((alpha * (d18Ow_PDB / 1000 + 1)) - 1) * 1000 # Calculate d18O of calcite for each sample according to Kim and O'Neil, 1997
}else if(d18O_fun == "GrossmanKu86"){
d18Oc <- (20.6 - SSTnew) / 4.34 + d18Ow + 0.2 # Use Grossmann and Ku (1986) modified by Dettmann et al. (1999)
}else{
return("ERROR: Supplied d18Oc transfer function is not recognized")
}
if(D47_fun == "Bernasconi18"){
D47 <- (0.0449 * 10 ^ 6) / (SSTnew + 273.15) ^ 2 + 0.167 # Calculate D47 of calcite for each sample according to Kele et al., 2015 modified by Bernasconi et al., 2018
}else if(D47_fun == "Jautzy20"){
D47 <- (0.0433 * 10 ^ 6) / (SSTnew + 273.15) ^ 2 + 0.119 + 0.066 # Calculate D47 of calcite for each sample according to Jautzy et al., 2020 brought into 25 degrees CDES reference frame using 70-25 acid fractionation factor by Petersen et al., 2019
}else{
return("ERROR: Supplied D47 transfer function is not recognized")
}
if(plot == TRUE){ # Create plots of new data if requested
plot(D, d18Oc, col = "blue")
lines(D, d18Oc, col = "blue")
par(new = TRUE)
plot(D, D47, axes = FALSE, bty = "n", xlab = "", ylab = "", col = "red")
lines(D, D47, axes = FALSE, bty = "n", xlab = "", ylab = "", col = "red")
axis(side = 4, at = pretty(range(D47)))
}
dat<-cbind(Tnew, D, d18Oc, D47) # Combine new data for export
return(dat) # Return the new depth, d18Oc and D47 series
}
newdata <- carbmodel(Ty, SST, GR, d18Osw, D, AV = TRUE, plot = TRUE)
carbmodel<-function(time,
SST,
GR,
d18Ow,
D,
d18O_fun = "KimONeil97",
D47_fun = "Bernasconi18",
AV=FALSE,
plot=FALSE
){
Dday<-cumsum(GR) # Create vector linking days to depth values
if(AV==FALSE){
SSTnew <- subsample(SST, Dday, D) # Subsample SST along the new sample set
d18Ownew <- subsample(d18Ow, Dday, D) # Subsample d18Ow along the new sample set
Tnew <- subsample(Ty, Dday, D) # Subsample time (yr) along the new sample set
}else{
SSTnew <- subsample_mean(SST, Dday, D) # Subsample SST along the new sample set using mean values
d18Ownew <- subsample_mean(d18Ow, Dday, D) # Subsample d18Ow along the new sample set using mean values
Tnew <- subsample_mean(Ty, Dday, D) # Subsample time (yr) along the new sample set using mean values
}
if(d18O_fun == "KimONeil97"){
alpha = exp((18.03 * 1000 / (SSTnew + 273.15) - 33.42) / 1000) # Calculate alpha of calcite fractionation
d18Ow_PDB = (0.97002 * d18Ownew - 29.98) # Convert d18Ow to PDB (following Brand et al., 2014)
d18Oc = ((alpha * (d18Ow_PDB / 1000 + 1)) - 1) * 1000 # Calculate d18O of calcite for each sample according to Kim and O'Neil, 1997
}else if(d18O_fun == "GrossmanKu86"){
d18Oc <- (20.6 - SSTnew) / 4.34 + d18Ow + 0.2 # Use Grossmann and Ku (1986) modified by Dettmann et al. (1999)
}else{
return("ERROR: Supplied d18Oc transfer function is not recognized")
}
if(D47_fun == "Bernasconi18"){
D47 <- (0.0449 * 10 ^ 6) / (SSTnew + 273.15) ^ 2 + 0.167 # Calculate D47 of calcite for each sample according to Kele et al., 2015 modified by Bernasconi et al., 2018
}else if(D47_fun == "Jautzy20"){
D47 <- (0.0433 * 10 ^ 6) / (SSTnew + 273.15) ^ 2 + 0.119 + 0.066 # Calculate D47 of calcite for each sample according to Jautzy et al., 2020 brought into 25 degrees CDES reference frame using 70-25 acid fractionation factor by Petersen et al., 2019
}else{
return("ERROR: Supplied D47 transfer function is not recognized")
}
if(plot == TRUE){ # Create plots of new data if requested
plot(D, d18Oc, col = "blue")
lines(D, d18Oc, col = "blue")
par(new = TRUE)
plot(D, D47, axes = FALSE, bty = "n", xlab = "", ylab = "", col = "red")
lines(D, D47, bty = "n", xlab = "", ylab = "", col = "red")
axis(side = 4, at = pretty(range(D47)))
}
dat<-cbind(Tnew, D, d18Oc, D47) # Combine new data for export
return(dat) # Return the new depth, d18Oc and D47 series
}
newdata <- carbmodel(Ty, SST, GR, d18Osw, D, AV = TRUE, plot = TRUE)
D_cum <- cumsum(GR)
"SSTnew <- subsample(SST, D_cum, D)"
data = SST
old_depth = D_cum
new_depth = D
?approx
linterp <- approx(
x = old_depth,
y = data,
xout = new_depth,
method = "linear"
)
newdata <- linterp$y
lwr <- c(0, diff(new_depth))
lwr <- c(0, diff(new_depth) / 2)
lwr <- new_depth - c(0, diff(new_depth) / 2)
upr <- new_depth + c(diff(new_depth) / 2, 0)
lwr <- new_depth - c(new_depth[1], diff(new_depth) / 2)
upr <- new_depth + c(diff(new_depth) / 2, new_depth[length(new_depth)])
?match
"test <- apply(lwr, 1, )
)
?vapply
length(which(old_depth < lwr))
test <- apply(lwr, which.min(abs(lwr - old_depth)))
test <- vapply(lwr, which.min(abs(lwr - old_depth)))
test <- lapply(lwr, function(x) which.min(abs(x - old_depth)))
test <- vapply(lwr, function(x) which.min(abs(x - old_depth)))
test <- vapply(lwr, function(x) which.min(abs(x - old_depth)), FUN.VALUE = lwr)
test <- vapply(lwr, function(x) which.min(abs(x - old_depth)), FUN.VALUE = 1)
test <- vapply(lwr, function(x) which.min(abs(x - old_depth)), 1)
lwrpos <- vapply(lwr, function(x) which.min(abs(x - old_depth)), 1) # Find position of lower boundaries of sample intervals in old_data
uprpos <- vapply(upr, function(x) which.min(abs(x - old_depth)), 1) # Find position of upper boundaries of sample intervals in old_data
uprpos[160]
test <- mean(data[lwrpos:uprpos])
test <- vapply(lwrpos, function(x) mean(data[lwrpos[x]:uprpos[x]]), 1)
test <- vapply(1:160, function(x) mean(data[lwrpos[x]:uprpos[x]]), 1)
test <- vapply(1:length(lwrpos), function(x) mean(data[lwrpos[x]:uprpos[x]]), 1)
x11(); plot(new_depth, newdata)
